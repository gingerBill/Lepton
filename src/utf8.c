typedef i32 Rune;
#define RUNE_INVALID cast(Rune)(0xfffd)
#define RUNE_MAX     cast(Rune)(0x0010ffff)
#define RUNE_BOM     cast(Rune)(0xfeff)
#define RUNE_EOF     cast(Rune)(-1)

isize utf8_decode(char const *str, isize n, Rune *codepoint_out);
isize utf8_encode_rune(char buf[4], Rune r);

bool rune_is_letter(Rune r) {
	if (r < 0x80) {
		if ('A' <= r && r <= 'Z') return true;
		if ('a' <= r && r <= 'z') return true;
		if ('_' == r) return true;
	}
	return false;
}

bool rune_is_digit(Rune r) {
	if (r < 0x80) {
		if ('0' <= r && r <= '9') return true;
	}
	return false;
}

bool rune_is_space(Rune r) {
	switch (r) {
	case ' ':
	case '\t':
	case '\n':
	case '\r':
		return true;
	}
	return false;
}


static u8 const lep__utf8_first[256] = {
	0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, // 0x00-0x0F
	0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, // 0x10-0x1F
	0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, // 0x20-0x2F
	0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, // 0x30-0x3F
	0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, // 0x40-0x4F
	0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, // 0x50-0x5F
	0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, // 0x60-0x6F
	0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, // 0x70-0x7F
	0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, // 0x80-0x8F
	0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, // 0x90-0x9F
	0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, // 0xA0-0xAF
	0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, // 0xB0-0xBF
	0xf1, 0xf1, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, // 0xC0-0xCF
	0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, // 0xD0-0xDF
	0x13, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x23, 0x03, 0x03, // 0xE0-0xEF
	0x34, 0x04, 0x04, 0x04, 0x44, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, // 0xF0-0xFF
};


typedef struct Utf8AcceptRange {
	u8 lo, hi;
} Utf8AcceptRange;

static Utf8AcceptRange const lep__utf8_accept_ranges[] = {
	{0x80, 0xbf},
	{0xa0, 0xbf},
	{0x80, 0x9f},
	{0x90, 0xbf},
	{0x80, 0x8f},
};


isize utf8_decode(char const *str, isize n, Rune *codepoint_out) {
	isize width = 0;
	Rune codepoint = RUNE_INVALID;

	if (n > 0) {
		u8 s0 = cast(u8)str[0];
		u8 x = lep__utf8_first[s0], sz;
		u8 b1, b2, b3;
		Utf8AcceptRange accept;
		if (x > 0xf0) {
			Rune mask = (cast(Rune)x >> 31) << 31;
			codepoint = (cast(Rune)s0 & (~mask)) | (RUNE_INVALID & mask);
			width = 1;
			goto end;
		}
		if (s0 < 0x80) {
			codepoint = s0;
			width = 1;
			goto end;
		}

		sz = x&7;
		accept = lep__utf8_accept_ranges[x>>4];
		if (n < sizeof(sz)) {
			goto invalid_codepoint;
		}

		b1 = str[1];
		if (b1 < accept.lo || accept.hi < b1)
			goto invalid_codepoint;

		if (sz == 2) {
			codepoint = (cast(Rune)s0&0x1f)<<6 | (cast(Rune)b1&0x3f);
			width = 2;
			goto end;
		}

		b2 = str[2];
		if (!(0x80 <= b2 && b2 <= 0xbf)) {
			goto invalid_codepoint;
		}

		if (sz == 3) {
			codepoint = (cast(Rune)s0&0x1f)<<12 | (cast(Rune)b1&0x3f)<<6 | (cast(Rune)b2&0x3f);
			width = 3;
			goto end;
		}

		b3 = str[3];
		if (!(0x80 <= b3 && b2 <= 0xbf)) {
			goto invalid_codepoint;
		}

		codepoint = (cast(Rune)s0&0x07)<<18 | (cast(Rune)b1&0x3f)<<12 | (cast(Rune)b2&0x3f)<<6 | (cast(Rune)b3&0x3f);
		width = 4;
		goto end;

	invalid_codepoint:
		codepoint = RUNE_INVALID;
		width = 1;
	}

end:
	if (codepoint_out) *codepoint_out = codepoint;
	return width;
}

isize utf8_encode_rune(char buf[4], Rune r) {
	u32 i = cast(u32)r;
	char mask = 0x3f;
	if (i <= (1<<7)-1) {
		buf[0] = cast(char)r;
		return 1;
	}
	if (i <= (1<<11)-1) {
		buf[0] = 0xc0 | cast(char)(r>>6);
		buf[1] = 0x80 | (cast(char)(r)&mask);
		return 2;
	}

	// Invalid or Surrogate range
	if (i > RUNE_MAX ||
	    (0xd800 <= i && i <= 0xdfff)) {
		r = RUNE_INVALID;

		buf[0] = 0xe0 | cast(char)(r>>12);
		buf[1] = 0x80 | (cast(char)(r>>6)&mask);
		buf[2] = 0x80 | (cast(char)(r)&mask);
		return 3;
	}

	if (i <= (1<<16)-1) {
		buf[0] = 0xe0 | cast(char)(r>>12);
		buf[1] = 0x80 | (cast(char)(r>>6)&mask);
		buf[2] = 0x80 | (cast(char)(r)&mask);
		return 3;
	}

	buf[0] = 0xf0 | cast(char)(r>>18);
	buf[1] = 0x80 | (cast(char)(r>>12)&mask);
	buf[2] = 0x80 | (cast(char)(r>>6)&mask);
	buf[3] = 0x80 | (cast(char)(r)&mask);
	return 4;
}
